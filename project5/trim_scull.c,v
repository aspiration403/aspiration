head	1.14;
access;
symbols;
locks
	root:1.14; strict;
comment	@ * @;


1.14
date	2015.12.22.06.20.50;	author root;	state Exp;
branches;
next	1.13;

1.13
date	2015.07.05.17.40.30;	author root;	state Exp;
branches;
next	1.12;

1.12
date	2015.07.05.17.39.06;	author root;	state Exp;
branches;
next	1.11;

1.11
date	2015.07.05.17.37.27;	author root;	state Exp;
branches;
next	1.10;

1.10
date	2015.07.05.17.30.40;	author root;	state Exp;
branches;
next	1.9;

1.9
date	2015.07.05.17.27.41;	author root;	state Exp;
branches;
next	1.8;

1.8
date	2015.07.05.17.16.26;	author root;	state Exp;
branches;
next	1.7;

1.7
date	2015.07.05.17.14.41;	author root;	state Exp;
branches;
next	1.6;

1.6
date	2015.07.05.16.27.53;	author root;	state Exp;
branches;
next	1.5;

1.5
date	2015.07.05.16.26.56;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2015.07.05.16.00.18;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2015.07.05.15.56.45;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2015.07.05.15.54.03;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2015.07.05.12.42.03;	author root;	state Exp;
branches;
next	;


desc
@this is for trimming the scull
when writer came
@


1.14
log
@*** empty log message ***
@
text
@#include"header.h"
#include"myDriver.h"
 int trim_scull(struct dev *ldev)
{
	struct dev *tdev=NULL;
	struct Qset *start,*lqset,*prev_qset=NULL; 
	int start_flag=0,i,count,num_qntm,nq;
	tdev=ldev;
	num_qntm = tdev->num_qset;
	printk(KERN_INFO "Entry inside %s",__func__);
	printk(KERN_INFO "Number of Quantum=%d \n",num_qntm);
	if(tdev->qset_node)
	{
		prev_qset=start=lqset=tdev->qset_node;
	
	}
	else
	{
		printk(KERN_INFO "Scull is Empty \n");
		goto OUT;
	}
	while(start)
	{
		count = 0;
		lqset = start;
		if(NULL== start->next)
		{
			printk(KERN_INFO " Trimming first node\n");
			start_flag = 1;
		}
		
		while(lqset->next)
		{
			count++;
			prev_qset = lqset;
			lqset = lqset->next;
		}   
	    
        	if(lqset->data)
		{
			
			printk(KERN_INFO " -----Trimming  -----%d ---qset----\n ",count);
			if(num_qntm > 0 && ((num_qntm % QSET_SIZE)!=0))
			{
				nq= (num_qntm % QSET_SIZE);	
			}
			else if(num_qntm == 0)
			{
				printk(KERN_INFO "!!!!!! This qset has no Quantum \n");
				nq = 0;
			}
			else
				nq = QSET_SIZE;
	
					
                        for(i=0; i < nq;i++)
			{
				if(lqset->data[i])
				{
					kfree(lqset->data[i]);
					lqset->data[i] = NULL;
					printk(KERN_INFO "Quantum --->%d   is Now freed up  \n",i);
				}
				else
				{
					printk(KERN_INFO "Quantum %d  Data is NULL  \n",i);
					kfree(lqset->data[i]);
				
				}		
			
			}
			num_qntm = num_qntm-nq;
			lqset->data = NULL;
			if(start_flag == 1)
			{
				kfree(lqset);
				lqset = NULL;
				prev_qset = NULL;
			}
			else
			{
				kfree(lqset);
				lqset =NULL;
				prev_qset->next = NULL;
			}
		
		}
		else
		{
			printk(KERN_INFO "--------free the Scull Data ------  \n");
			kfree(lqset);
			lqset = NULL;
			prev_qset->next = NULL;
		}
		
		if(start_flag == 1)
			break;
	}





	
	printk(KERN_INFO "End inside %s",__func__);
		
	return 0;
	
	OUT:
		return -1;
}
@


1.13
log
@*** empty log message ***
@
text
@d3 1
a3 1
extern int trim_scull(struct dev *ldev)
@


1.12
log
@*** empty log message ***
@
text
@d42 1
a42 1
			printk(KERN_INFO " -----Trimming  -----%d ---qset----=%d\n ",count);
@


1.11
log
@*** empty log message ***
@
text
@d42 1
a42 1
			printk(KERN_INFO " -----Trimming  -----%d ---qset----Qset size =%d-\n ",count,QSET_SIZE);
@


1.10
log
@setting the number of quantum to trim
@
text
@d42 1
a42 1
			printk(KERN_INFO " -----Trimming  -----%d ---qset----\n ",count);
d72 1
a72 1
			num_qntm -=nq;
@


1.9
log
@*** empty log message ***
@
text
@d72 1
@


1.8
log
@*** empty log message ***
@
text
@d9 1
a9 1
	num_qntm = tdev->num_quantum;
@


1.7
log
@correcting the number of quantum to read
@
text
@d45 1
a45 1
				nq = (num_quantum % QSET_SIZE);	
d56 1
a56 1
                        for(i=0; i < nq,i++)
@


1.6
log
@*** empty log message ***
@
text
@d7 1
a7 1
	int start_flag=0,i,count;
d9 1
d11 1
d43 14
a56 1
			                                                                                                              for(i=0; i < QSET_SIZE; i++)
@


1.5
log
@now try to print which qset is trimming
@
text
@d7 1
a7 1
	int start_flag=0,i;
@


1.4
log
@*** empty log message ***
@
text
@d7 1
a7 1
	int start_flag=0,i,count=0;
d22 1
d32 1
d39 2
a40 2
			count++;
			printk(KERN_INFO " -----Free -----%d ---qset----\n ",count);
@


1.3
log
@*** empty log message ***
@
text
@d17 1
a17 1
		printk(KERN_INFO "Scull is Empty \n"_);
d73 1
a73 1
			free(lqset);
@


1.2
log
@written down the function of trimming
firstly seleceted the first sqset
and then travel to last
thereafter sqset is deleted one by one
@
text
@a4 1
	printk(KERN_INFO "Entry inside %s",__func__);
d9 1
d12 1
a12 1
		prev_qset=start=lqset=tdev->qset;
@


1.1
log
@Initial revision
@
text
@d6 80
a85 2
	//struct dev *tdev=NULL;
	//tdev=ldev;
d89 4
a92 1
	return 0;	
@
