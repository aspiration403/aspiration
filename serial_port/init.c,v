head	1.7;
access;
symbols;
locks
	root:1.7; strict;
comment	@ * @;


1.7
date	2015.11.04.06.01.40;	author root;	state Exp;
branches;
next	1.6;

1.6
date	2015.11.03.07.20.56;	author root;	state Exp;
branches;
next	1.5;

1.5
date	2015.11.03.07.12.47;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2015.11.03.06.54.40;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2015.11.03.06.52.07;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2015.11.03.06.10.07;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2015.11.03.05.57.54;	author root;	state Exp;
branches;
next	;


desc
@writting driver for parallel port
first step is to register our device
for this we use alloc_chrdev_region(dev_t *,minor_no,no. of device ,driver name)
this is in fs.h header file
@


1.7
log
@define number of port and first port of parallel port
then first step is to check free region
second step is request region
and third is release region
@
text
@#include"header.h"
#include"declaration.h"
#include"file_operation.h"
int minor =0,major; 
dev_t pdevice;
struct mydev *Dev;
unsigned long num_port 		= NUM_PORT;
unsigned long first_port	= FIRST_PORT;
static int __init entry(void)
{
	//#ifdef DEBUG
	printk(KERN_INFO "let's start learning of parallel port\n");
	//#endif
	//extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);  
	alloc_chrdev_region(&pdevice,minor,1,"P_Port_Driver");
	major = MAJOR(pdevice);
	//#ifdef DEBUG
	printk(KERN_INFO "Major No. =%d\n",major);
	//#endif
	
	Dev = (struct mydev *)kmalloc((sizeof(struct mydev)),GFP_KERNEL);
	memset(Dev,'\0',sizeof(struct mydev)); 
       //cdev_init(struct cdev *, const struct file_operations *);		initialize device
	cdev_init(&Dev->kern_dev,&fops);
	//int cdev_add(struct cdev *, dev_t, unsigned); //unsigned is no. od device adding ata time
	
	cdev_add(&Dev->kern_dev,pdevice,1);

	
	if(check_region(first_port,num_port)<3)
	{
		printk(KERN_ERR "release region first");
		release_region(first_port,num_port);
	}
	
	request_region(first_port,num_port,"P_PORT_DRIVER");


	return 0;
}
module_init(entry);



@


1.6
log
@now our last task is add our device in device table
cdev_add(struct cdev *,cdev_t ,1)
@
text
@d7 2
d28 9
@


1.5
log
@now fourth step is to initialize our driver
cdev_init(struct cdev *,&fops)
@
text
@d23 3
@


1.4
log
@third step is to set acquired memory to null
@
text
@d3 1
d21 2
a22 3
	
		

@


1.3
log
@secod step is to get memory from pool for our scull
using kmalloc
@
text
@d19 1
a19 1
	 
@


1.2
log
@driver is registerd for one device
and we fetched out its major no.
@
text
@d2 4
a5 2
int minor =0; 
int dev_t pdevice;
d8 1
a8 1
	#ifdef DEBUG
d10 1
a10 1
	#endif
d13 2
a14 2
	major = MAJOR(&pdevice);
	#ifdef DEBUG
d16 4
a19 1
	#endif
@


1.1
log
@Initial revision
@
text
@d3 1
d6 1
d8 1
d10 5
d16 1
@
