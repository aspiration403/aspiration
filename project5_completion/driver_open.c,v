head	1.5;
access;
symbols;
locks
	root:1.4
	root:1.5; strict;
comment	@ * @;


1.5
date	2011.06.21.10.26.22;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2011.06.21.10.22.21;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2011.06.21.10.04.27;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2011.06.21.09.02.13;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2011.06.21.07.31.01;	author root;	state Exp;
branches;
next	;


desc
@to open te driver
it will perform our open call whose name is driver_open
instead of open system call
@


1.5
log
@*** empty log message ***
@
text
@@


1.4
log
@*** empty log message ***
@
text
@a0 16
#include "header.h"
#include "myDriver.h"
int extern driver_open(struct inode *p,struct file * fp) 
{

	struct dev *ldev;
	printk(KERN_INFO "in %s File open sucessfully",__func__);
//	struct inode *cdev_addr;
	ldev=container_of(p->i_cdev,struct dev,kern_cdev);
//
	if(!ldev)
		printk(KERN_ERR "container of error");
	else
		printk(KERN_INFO "mapped to io space sucessfully");
	return 0;
}
@


1.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
//	struct dev *ldev;
d9 6
a14 5
//	ldev=container_of(p->i_cdev,struct dev,kern_cdev);
//	if(!ldev)
//		printk(KERN_INFO "mapped to io space sucessfully");
//	else
//		printk(KERN_ERR "container of error");
@


1.2
log
@used container of for mapping into io space
first argument is cdev of inode structure
second is of our scull type
third argument is cdev of our scull
it will verify the major and minor no. from file system view and dd view
@
text
@d6 1
a6 1
	struct dev *ldev;
d9 5
a13 5
	ldev=container_of(p->i_cdev,struct dev,kern_cdev);
	if(!ldev)
		printk(KERN_INFO "mapped to io space sucessfully");
	else
		printk(KERN_ERR "container of error");
@


1.1
log
@Initial revision
@
text
@d5 9
a13 1
	printk(KERN_INFO "File open in driver mode");
@
